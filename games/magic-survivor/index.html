<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë§¤ì§ ì„œë°”ì´ë²„</title>
    <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Noto+Sans+KR:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Noto Sans KR', sans-serif; touch-action: none; user-select: none; }
        
        #gameLayer { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
        canvas { display: block; }

        /* UI ë ˆì´ì–´ */
        .ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* ìƒë‹¨ ì •ë³´ì°½ */
        .hud-top { display: flex; justify-content: space-between; padding: 15px; pointer-events: none; }
        .xp-bar-container { 
            position: absolute; top: 0; left: 0; width: 100%; height: 10px; background: #333; z-index: 10; 
        }
        .xp-bar { width: 0%; height: 100%; background: #00ff9d; transition: width 0.2s; box-shadow: 0 0 10px #00ff9d; }
        .level-badge { background: rgba(0,0,0,0.7); color: white; padding: 5px 15px; border-radius: 20px; font-weight: bold; border: 1px solid #555; }
        .timer { font-family: 'Black Han Sans'; font-size: 1.5rem; color: white; text-shadow: 2px 2px 0 #000; }
        .kill-count { color: #ff4757; font-weight: bold; text-shadow: 1px 1px 0 #000; }

        /* ë ˆë²¨ì—… ì„ íƒì°½ */
        #levelUpScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100; display: none;
            flex-direction: column; align-items: center; justify-content: center; pointer-events: auto;
        }
        .skill-card {
            background: #222; border: 2px solid #444; border-radius: 15px;
            padding: 15px; margin: 10px; width: 80%; max-width: 400px;
            display: flex; align-items: center; gap: 15px; cursor: pointer; transition: 0.2s;
        }
        .skill-card:hover { background: #333; border-color: #00ff9d; transform: scale(1.02); }
        .skill-icon { width: 50px; height: 50px; background: #000; border-radius: 10px; object-fit: cover; }
        .skill-info h3 { margin: 0; color: #00ff9d; font-size: 1.1rem; }
        .skill-info p { margin: 5px 0 0; color: #ccc; font-size: 0.8rem; }

        /* ê°€ìƒ ì¡°ì´ìŠ¤í‹± (ëª¨ë°”ì¼ìš©) */
        #joystick-zone {
            position: absolute; bottom: 50px; left: 50px; width: 150px; height: 150px;
            z-index: 50; display: none; /* ëª¨ë°”ì¼ì—ì„œë§Œ ë³´ì„ */
            pointer-events: auto;
        }

        /* ê²Œì„ ì˜¤ë²„ */
        #gameOverScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.9); z-index: 200; display: none;
            flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; text-align: center;
        }
        .btn {
            background: #00ff9d; color: black; border: none; padding: 15px 40px;
            font-size: 1.2rem; border-radius: 50px; font-family: 'Black Han Sans';
            margin-top: 15px; cursor: pointer; box-shadow: 0 5px 0 #00b870;
        }
        .btn-revive { background: #FFD700; box-shadow: 0 5px 0 #c5a600; animation: pulse 1s infinite; }
        @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.05);} 100% {transform: scale(1);} }

        /* ê´‘ê³  ì˜ì—­ */
        .ad-banner-area { position: absolute; bottom: 0; width: 100%; height: 100px; background: rgba(0,0,0,0.8); z-index: 90; display: flex; justify-content: center; align-items: center; pointer-events: auto; }

        @media (max-width: 768px) {
            #joystick-zone { display: block; bottom: 120px; left: 50%; transform: translateX(-50%); opacity: 0.6; }
        }
    </style>
</head>
<body>

    <div id="gameLayer">
        <canvas id="gameCanvas"></canvas>

        <div class="ui-overlay">
            <div class="xp-bar-container"><div class="xp-bar" id="xpBar"></div></div>
            
            <div class="hud-top">
                <div class="level-badge">LV.<span id="levelDisp">1</span></div>
                <div class="timer" id="timeDisp">00:00</div>
                <div class="kill-count">â˜ ï¸ <span id="killDisp">0</span></div>
            </div>

            <div id="joystick-zone">
                <div style="width:100%; height:100%; border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; position: relative;">
                    <div id="stick" style="width:50px; height:50px; background: rgba(0,255,157,0.5); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);"></div>
                </div>
            </div>
        </div>

        <div id="levelUpScreen">
            <h1 style="color:#FFD700; font-family:'Black Han Sans'; font-size:3rem; margin-bottom:20px; text-shadow: 0 0 20px #FFD700;">LEVEL UP!</h1>
            <div id="skillOptions"></div>
        </div>

        <div id="gameOverScreen">
            <h1 style="color:#ff4757; font-size:3rem; margin:0;">YOU DIED</h1>
            <p style="color:white; font-size:1.2rem;">ìƒì¡´ ì‹œê°„: <span id="finalTime">00:00</span></p>
            <button class="btn btn-revive" onclick="revive()">ğŸ“º ê´‘ê³ ë³´ê³  ë¶€í™œí•˜ê¸° (HP 100%)</button>
            <button class="btn" onclick="location.reload()" style="background:#fff;">ì²˜ìŒë¶€í„° ë‹¤ì‹œí•˜ê¸°</button>
            <a href="../../index.html" style="color:#aaa; margin-top:20px; display:block; text-decoration:none;">í™ˆìœ¼ë¡œ ë‚˜ê°€ê¸°</a>
        </div>

        <div class="ad-banner-area" id="ad-game-bottom"></div>
    </div>

    <audio id="bgm" src="../../audio/magic-survivor/bgm_battle.mp3" loop></audio>
    <audio id="sfx-hit" src="../../audio/magic-survivor/sfx_hit.mp3"></audio>
    <audio id="sfx-levelup" src="../../audio/magic-survivor/sfx_levelup.mp3"></audio>
    <audio id="sfx-magic" src="../../audio/magic-survivor/sfx_magic.mp3"></audio>

    <script src="../../js/ads.js"></script>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // í™”ë©´ ì„¤ì •
        let W, H;
        function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize);
        resize();

        // ìì‚° ë¡œë“œ
        const images = {};
        const assetList = ['player', 'bg_tile', 'enemy_1', 'enemy_2', 'enemy_boss', 'gem', 'icon_fireball', 'icon_lightning', 'icon_shield', 'icon_heal'];
        assetList.forEach(name => {
            images[name] = new Image();
            images[name].src = `../../images/magic-survivor/${name}.png`;
        });

        // ê²Œì„ ìƒíƒœ
        let gameState = 'playing'; // playing, paused, gameover
        let frames = 0;
        let score = 0;
        let time = 0;
        let level = 1;
        let xp = 0;
        let xpNext = 100;

        // í”Œë ˆì´ì–´
        const player = { x: W/2, y: H/2, speed: 3, hp: 100, maxHp: 100, size: 40, direction: 1 };
        
        // ì—”í‹°í‹° ë°°ì—´
        let enemies = [];
        let gems = [];
        let projectiles = [];
        let floatingTexts = [];
        let particles = [];

        // ìŠ¤í‚¬ ë°ì´í„°
        const SKILLS = {
            fireball: { name: "í™”ì—¼êµ¬", desc: "ê°€ì¥ ê°€ê¹Œìš´ ì ì—ê²Œ ë¶ˆë©ì´ ë°œì‚¬", level: 1, damage: 20, cooldown: 60, timer: 0, icon: 'icon_fireball' },
            lightning: { name: "ë²¼ë½", desc: "ë¬´ì‘ìœ„ ì ì—ê²Œ ë²¼ë½ì„ ë‚´ë¦¬ê½‚ìŒ", level: 0, damage: 50, cooldown: 120, timer: 0, icon: 'icon_lightning' },
            shield: { name: "íšŒì „ ì¹¼ë‚ ", desc: "ì£¼ë³€ì„ ë„ëŠ” ë³´í˜¸ë§‰ ìƒì„±", level: 0, damage: 10, count: 0, icon: 'icon_shield' },
            heal: { name: "ì¬ìƒë ¥", desc: "5ì´ˆë§ˆë‹¤ ì²´ë ¥ 5 íšŒë³µ", level: 0, amount: 5, cooldown: 300, timer: 0, icon: 'icon_heal' }
        };

        // ì¡°ì‘ ê´€ë ¨
        const keys = {};
        const joystick = { active: false, dx: 0, dy: 0, originX: 0, originY: 0 };

        // --- ë©”ì¸ ë£¨í”„ ---
        function loop() {
            if (gameState === 'playing') {
                update();
                draw();
                frames++;
            }
            requestAnimationFrame(loop);
        }

        function update() {
            // 1. í”Œë ˆì´ì–´ ì´ë™
            let moveX = 0, moveY = 0;
            if (keys['ArrowUp'] || keys['w']) moveY = -1;
            if (keys['ArrowDown'] || keys['s']) moveY = 1;
            if (keys['ArrowLeft'] || keys['a']) moveX = -1;
            if (keys['ArrowRight'] || keys['d']) moveX = 1;

            if (joystick.active) {
                moveX = joystick.dx;
                moveY = joystick.dy;
            }

            // ì •ê·œí™” ë° ì†ë„ ì ìš©
            if (moveX !== 0 || moveY !== 0) {
                const len = Math.sqrt(moveX*moveX + moveY*moveY);
                moveX /= len; moveY /= len;
                player.x += moveX * player.speed;
                player.y += moveY * player.speed;
                if(moveX !== 0) player.direction = moveX > 0 ? 1 : -1;
            }

            // ë§µ ê²½ê³„ ì œí•œ (ë¬´í•œ ë§µ ì•„ë‹˜)
            const mapLimit = 2000;
            player.x = Math.max(-mapLimit, Math.min(mapLimit, player.x));
            player.y = Math.max(-mapLimit, Math.min(mapLimit, player.y));

            // 2. ìŠ¤í‚¬ ë°œë™
            updateSkills();

            // 3. ì  ìƒì„± (ì›¨ì´ë¸Œ ì‹œìŠ¤í…œ)
            if (frames % 60 === 0) { // 1ì´ˆë§ˆë‹¤ ì²´í¬
                time++;
                document.getElementById('timeDisp').innerText = formatTime(time);
                
                // ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ì ì´ ë§ì•„ì§€ê³  ê°•í•´ì§
                const spawnRate = Math.max(10, 60 - Math.floor(time/10)); 
                if (frames % spawnRate === 0) spawnEnemy();
            }
            if (frames % 30 === 0 && enemies.length < 50 + (time/2)) spawnEnemy(); // ê¸°ë³¸ ìŠ¤í°

            // 4. ì  ì´ë™ ë° ì¶©ëŒ
            enemies.forEach((e, i) => {
                const angle = Math.atan2(player.y - e.y, player.x - e.x);
                e.x += Math.cos(angle) * e.speed;
                e.y += Math.sin(angle) * e.speed;

                // í”Œë ˆì´ì–´ ì¶©ëŒ
                const dist = Math.hypot(player.x - e.x, player.y - e.y);
                if (dist < player.size/2 + e.size/2) {
                    player.hp -= 0.5; // ì§€ì† ë°ë¯¸ì§€
                    if (player.hp <= 0) gameOver();
                }
            });

            // 5. íˆ¬ì‚¬ì²´ ì´ë™ ë° ì¶©ëŒ
            projectiles.forEach((p, pi) => {
                p.x += Math.cos(p.angle) * p.speed;
                p.y += Math.sin(p.angle) * p.speed;
                p.life--;

                // ì ê³¼ ì¶©ëŒ
                enemies.forEach((e, ei) => {
                    if (p.hitList.includes(ei)) return; // ê´€í†µ ìŠ¤í‚¬ìš© (ì§€ê¸ˆì€ ë‹¨ì¼)
                    const dist = Math.hypot(p.x - e.x, p.y - e.y);
                    if (dist < p.size + e.size/2) {
                        e.hp -= p.damage;
                        createDamageText(p.damage, e.x, e.y);
                        createParticles(e.x, e.y, p.color);
                        
                        if (!p.pierce) p.life = 0; // ê´€í†µ ì—†ìœ¼ë©´ ì†Œë©¸
                        else p.hitList.push(ei);

                        if (e.hp <= 0) killEnemy(ei);
                    }
                });
            });
            projectiles = projectiles.filter(p => p.life > 0);

            // 6. ì•„ì´í…œ(ë³´ì„) íšë“
            gems.forEach((g, i) => {
                const dist = Math.hypot(player.x - g.x, player.y - g.y);
                if (dist < 150) { // ìì„ íš¨ê³¼
                    g.x += (player.x - g.x) * 0.1;
                    g.y += (player.y - g.y) * 0.1;
                }
                if (dist < 30) {
                    getGem(g.xp);
                    gems.splice(i, 1);
                }
            });

            // ê¸°íƒ€ ì—…ë°ì´íŠ¸
            floatingTexts = floatingTexts.filter(t => t.life-- > 0);
            particles = particles.filter(p => p.life-- > 0);
        }

        function draw() {
            // ì¹´ë©”ë¼ ì²˜ë¦¬
            const cx = player.x - W/2;
            const cy = player.y - H/2;

            // 1. ë°°ê²½ ê·¸ë¦¬ê¸° (íƒ€ì¼ë§)
            if (images.bg_tile.complete) {
                const ptrn = ctx.createPattern(images.bg_tile, 'repeat');
                ctx.fillStyle = ptrn;
                ctx.save();
                ctx.translate(-cx, -cy);
                ctx.fillRect(cx, cy, W, H);
                ctx.restore();
            } else {
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(0, 0, W, H);
            }

            ctx.save();
            ctx.translate(-cx, -cy);

            // 2. ì•„ì´í…œ
            gems.forEach(g => {
                if(images.gem.complete) ctx.drawImage(images.gem, g.x-10, g.y-10, 20, 20);
                else { ctx.fillStyle = '#00ff9d'; ctx.beginPath(); ctx.arc(g.x, g.y, 5, 0, Math.PI*2); ctx.fill(); }
            });

            // 3. ì 
            enemies.forEach(e => {
                ctx.save();
                ctx.translate(e.x, e.y);
                if (e.x < player.x) ctx.scale(-1, 1);
                
                let img = images.enemy_1;
                if(e.type === 2) img = images.enemy_2;
                if(e.type === 3) img = images.enemy_boss;

                if(img.complete) ctx.drawImage(img, -e.size/2, -e.size/2, e.size, e.size);
                else { ctx.fillStyle = 'red'; ctx.fillRect(-e.size/2, -e.size/2, e.size, e.size); }
                ctx.restore();
            });

            // 4. í”Œë ˆì´ì–´
            ctx.save();
            ctx.translate(player.x, player.y);
            if (player.direction < 0) ctx.scale(-1, 1);
            if (images.player.complete) ctx.drawImage(images.player, -25, -25, 50, 50);
            else { ctx.fillStyle = 'white'; ctx.fillRect(-20, -20, 40, 40); }
            
            // ì²´ë ¥ë°”
            ctx.fillStyle = 'red'; ctx.fillRect(-20, -35, 40, 5);
            ctx.fillStyle = '#00ff9d'; ctx.fillRect(-20, -35, 40 * (player.hp/player.maxHp), 5);
            ctx.restore();

            // 5. íˆ¬ì‚¬ì²´ & ì´í™íŠ¸
            projectiles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
            });
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.beginPath(); ctx.arc(p.x + Math.random()*10, p.y + Math.random()*10, p.size, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1;
            });
            floatingTexts.forEach(t => {
                ctx.fillStyle = 'white'; ctx.font = 'bold 20px Arial';
                ctx.fillText(t.text, t.x, t.y - (30 - t.life));
            });

            // 6. ë³´í˜¸ë§‰(íšŒì „ ì¹¼ë‚ ) ì´í™íŠ¸
            if (SKILLS.shield.level > 0) {
                const count = SKILLS.shield.level + 1;
                const time = Date.now() / 500;
                for(let i=0; i<count; i++) {
                    const angle = time + (Math.PI * 2 * i / count);
                    const sx = player.x + Math.cos(angle) * 70;
                    const sy = player.y + Math.sin(angle) * 70;
                    
                    // ê·¸ë¦¬ê¸°
                    if(images.icon_shield.complete) ctx.drawImage(images.icon_shield, sx-15, sy-15, 30, 30);
                    else { ctx.fillStyle = 'cyan'; ctx.beginPath(); ctx.arc(sx, sy, 10, 0, Math.PI*2); ctx.fill(); }

                    // ì¶©ëŒ ë¡œì§ (ì—¬ê¸°ì„œ ê°™ì´ ì²˜ë¦¬)
                    enemies.forEach((e, ei) => {
                        if (Math.hypot(sx - e.x, sy - e.y) < 30) {
                            e.hp -= SKILLS.shield.damage;
                            if(frames % 10 === 0) createDamageText(SKILLS.shield.damage, e.x, e.y); // í…ìŠ¤íŠ¸ ë„ˆë¬´ ë§ì´ ëœ¨ì§€ ì•Šê²Œ
                            if (e.hp <= 0) killEnemy(ei);
                        }
                    });
                }
            }

            ctx.restore();
        }

        // --- ìŠ¤í‚¬ ë¡œì§ ---
        function updateSkills() {
            // 1. í™”ì—¼êµ¬
            if (SKILLS.fireball.level > 0) {
                SKILLS.fireball.timer++;
                if (SKILLS.fireball.timer >= Math.max(10, 60 - SKILLS.fireball.level*5)) {
                    SKILLS.fireball.timer = 0;
                    const target = getNearestEnemy();
                    if (target) {
                        shootProjectile(player.x, player.y, target, SKILLS.fireball.damage, 'orange', 8);
                        playSound('magic');
                    }
                }
            }
            // 2. ë²¼ë½
            if (SKILLS.lightning.level > 0) {
                SKILLS.lightning.timer++;
                if (SKILLS.lightning.timer >= 120) {
                    SKILLS.lightning.timer = 0;
                    const target = getRandomEnemy();
                    if (target) {
                        target.hp -= SKILLS.lightning.damage;
                        createDamageText(SKILLS.lightning.damage + "!", target.x, target.y);
                        createParticles(target.x, target.y, 'yellow', 20);
                        if(target.hp <= 0) killEnemy(enemies.indexOf(target));
                    }
                }
            }
            // 3. íšŒë³µ
            if (SKILLS.heal.level > 0) {
                SKILLS.heal.timer++;
                if (SKILLS.heal.timer >= 300) {
                    SKILLS.heal.timer = 0;
                    player.hp = Math.min(player.maxHp, player.hp + SKILLS.heal.amount * SKILLS.heal.level);
                    createFloatText("HEAL", player.x, player.y, 'green');
                }
            }
        }

        function shootProjectile(x, y, target, damage, color, speed) {
            const angle = Math.atan2(target.y - y, target.x - x);
            projectiles.push({ x, y, angle, speed, damage, color, size: 5, life: 100, pierce: false, hitList: [] });
        }

        function getNearestEnemy() {
            let nearest = null;
            let minDst = Infinity;
            enemies.forEach(e => {
                const d = Math.hypot(e.x - player.x, e.y - player.y);
                if (d < minDst) { minDst = d; nearest = e; }
            });
            return nearest;
        }
        function getRandomEnemy() {
            if (enemies.length === 0) return null;
            return enemies[Math.floor(Math.random() * enemies.length)];
        }

        // --- ì  & ê²Œì„ ë¡œì§ ---
        function spawnEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.max(W, H) / 2 + 50; // í™”ë©´ ë°– ìƒì„±
            const x = player.x + Math.cos(angle) * dist;
            const y = player.y + Math.sin(angle) * dist;
            
            let type = 1;
            let hp = 20 + (time * 2);
            let speed = 1.5;
            let size = 40;

            if (time > 60 && Math.random() < 0.3) { type = 2; hp *= 2; speed = 1.2; size = 50; } // ì¤‘í˜•
            if (time > 120 && Math.random() < 0.05) { type = 3; hp *= 10; speed = 0.8; size = 100; } // ë³´ìŠ¤

            enemies.push({ x, y, hp, maxHp: hp, type, speed, size });
        }

        function killEnemy(idx) {
            const e = enemies[idx];
            if (!e) return;
            
            // ê²½í—˜ì¹˜ ë“œë
            gems.push({ x: e.x, y: e.y, xp: e.type * 10 });
            
            // í‚¬ ì¹´ìš´íŠ¸
            score++;
            document.getElementById('killDisp').innerText = score;
            
            // ì‚­ì œ
            enemies.splice(idx, 1);
            playSound('hit');
        }

        function getGem(amount) {
            xp += amount;
            if (xp >= xpNext) {
                xp = 0;
                xpNext = Math.floor(xpNext * 1.2);
                levelUp();
            }
            updateXpBar();
        }

        function levelUp() {
            gameState = 'paused';
            level++;
            document.getElementById('levelDisp').innerText = level;
            playSound('levelup');
            
            // ìŠ¤í‚¬ ì„ íƒì§€ ìƒì„±
            const container = document.getElementById('skillOptions');
            container.innerHTML = "";
            
            const options = Object.keys(SKILLS).sort(() => 0.5 - Math.random()).slice(0, 3);
            
            options.forEach(key => {
                const s = SKILLS[key];
                const div = document.createElement('div');
                div.className = 'skill-card';
                div.innerHTML = `
                    <img src="../../images/magic-survivor/${s.icon}.png" class="skill-icon" onerror="this.style.background='gray'">
                    <div class="skill-info">
                        <h3>${s.name} <span style="font-size:0.8rem; color:#fff;">Lv.${s.level} -> ${s.level+1}</span></h3>
                        <p>${s.desc}</p>
                    </div>
                `;
                div.onclick = () => {
                    s.level++;
                    document.getElementById('levelUpScreen').style.display = 'none';
                    gameState = 'playing';
                };
                container.appendChild(div);
            });
            
            document.getElementById('levelUpScreen').style.display = 'flex';
        }

        function updateXpBar() {
            document.getElementById('xpBar').style.width = (xp / xpNext * 100) + "%";
        }

        function gameOver() {
            gameState = 'gameover';
            document.getElementById('bgm').pause();
            document.getElementById('finalTime').innerText = formatTime(time);
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function revive() {
            if(window.showRewardAd) {
                window.showRewardAd(() => {
                    player.hp = player.maxHp;
                    enemies = []; // ì  ì´ˆê¸°í™” (ì•ˆì „ í™•ë³´)
                    document.getElementById('gameOverScreen').style.display = 'none';
                    gameState = 'playing';
                    document.getElementById('bgm').play();
                });
            } else {
                alert("ê´‘ê³  ë¡œë”© ì¤‘...");
            }
        }

        // --- ìœ í‹¸ ---
        function createDamageText(dmg, x, y) {
            floatingTexts.push({ text: dmg, x, y, life: 30 });
        }
        function createFloatText(txt, x, y, color) {
             // (ìƒëµ: ìœ„ì™€ ë™ì¼ ë¡œì§)
        }
        function createParticles(x, y, color, count=5) {
            for(let i=0; i<count; i++) particles.push({ x, y, color, size: Math.random()*3, life: 20 });
        }
        function formatTime(sec) {
            const m = Math.floor(sec / 60).toString().padStart(2, '0');
            const s = (sec % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        }
        function playSound(id) {
            try { 
                const s = document.getElementById('sfx-'+id);
                if(s) { s.currentTime=0; s.play().catch(()=>{}); }
            } catch(e){}
        }

        // --- ì…ë ¥ ---
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);
        
        const joy = document.getElementById('joystick-zone');
        const stick = document.getElementById('stick');
        
        joy.addEventListener('touchstart', e => {
            joystick.active = true;
            joystick.originX = e.touches[0].clientX;
            joystick.originY = e.touches[0].clientY;
        });
        joy.addEventListener('touchmove', e => {
            if(!joystick.active) return;
            const dx = e.touches[0].clientX - joystick.originX;
            const dy = e.touches[0].clientY - joystick.originY;
            const dist = Math.min(50, Math.sqrt(dx*dx+dy*dy));
            const angle = Math.atan2(dy, dx);
            
            stick.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
            
            joystick.dx = Math.cos(angle);
            joystick.dy = Math.sin(angle);
        });
        joy.addEventListener('touchend', () => {
            joystick.active = false;
            joystick.dx = 0; joystick.dy = 0;
            stick.style.transform = `translate(-50%, -50%)`;
        });

        // BGM ì‹œì‘ (í´ë¦­ ì‹œ)
        window.addEventListener('click', () => {
            const bgm = document.getElementById('bgm');
            if(bgm.paused) { bgm.volume=0.3; bgm.play().catch(()=>{}); }
        }, {once:true});

        loop();
    </script>
</body>
</html>