<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Îß§ÏßÅ ÏÑúÎ∞îÏù¥Î≤Ñ V4 - Scale Fix</title>
    <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Noto+Sans+KR:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Noto Sans KR', sans-serif; touch-action: none; user-select: none; }
        
        #gameLayer { position: relative; width: 100%; height: 100vh; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }

        .ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        .hud-top { display: flex; justify-content: space-between; padding: 15px; pointer-events: none; z-index: 20; position: relative; }
        .xp-bar-container { position: absolute; top: 0; left: 0; width: 100%; height: 10px; background: #333; z-index: 10; }
        .xp-bar { width: 0%; height: 100%; background: #00ff9d; transition: width 0.2s; box-shadow: 0 0 10px #00ff9d; }
        
        .level-badge { background: rgba(0,0,0,0.7); color: white; padding: 5px 15px; border-radius: 20px; font-weight: bold; border: 2px solid #00ff9d; display: inline-block; margin-bottom: 5px; font-size: 1.2rem;}
        .kill-count { color: #ff4757; font-weight: bold; text-shadow: 1px 1px 0 #000; font-size: 1.5rem; }
        .timer { font-family: 'Black Han Sans'; font-size: 2.5rem; color: white; text-shadow: 3px 3px 0 #000; position: absolute; left: 50%; transform: translateX(-50%); top: 20px; }

        #levelUpScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100; display: none;
            flex-direction: column; align-items: center; justify-content: center; pointer-events: auto;
        }
        .skill-card {
            background: #222; border: 2px solid #444; border-radius: 15px;
            padding: 15px; margin: 10px; width: 85%; max-width: 400px;
            display: flex; align-items: center; gap: 15px; cursor: pointer; transition: 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .skill-card:hover { background: #333; border-color: #00ff9d; transform: scale(1.05); }
        .skill-icon { width: 60px; height: 60px; background: #000; border-radius: 10px; object-fit: cover; border: 1px solid #555; }
        .skill-info h3 { margin: 0; color: #00ff9d; font-size: 1.2rem; }
        .skill-info p { margin: 5px 0 0; color: #ccc; font-size: 0.9rem; }

        #joystick-zone {
            position: absolute; bottom: 150px; left: 50%; transform: translateX(-50%);
            width: 140px; height: 140px; z-index: 50; pointer-events: auto;
            border: 3px solid rgba(255,255,255,0.3); border-radius: 50%;
            display: none; 
        }
        #stick {
            width: 60px; height: 60px; background: rgba(0,255,157,0.6); border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(0,255,157,0.5);
        }

        #gameOverScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.9); z-index: 200; display: none;
            flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; text-align: center;
        }
        .btn {
            background: #00ff9d; color: black; border: none; padding: 15px 40px;
            font-size: 1.2rem; border-radius: 50px; font-family: 'Black Han Sans';
            margin-top: 15px; cursor: pointer; box-shadow: 0 5px 0 #00b870;
        }
        .btn-revive { background: #FFD700; box-shadow: 0 5px 0 #c5a600; animation: pulse 1s infinite; }
        @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.05);} 100% {transform: scale(1);} }

        .ad-banner-area { 
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100px; 
            background: rgba(0,0,0,0.8); z-index: 90; pointer-events: auto;
            display: flex; justify-content: center; align-items: center;
        }
        @media (max-width: 768px) { #joystick-zone { display: block; } }
    </style>
</head>
<body>

    <div id="gameLayer">
        <canvas id="gameCanvas"></canvas>

        <div class="ui-overlay">
            <div class="xp-bar-container"><div class="xp-bar" id="xpBar"></div></div>
            <div class="hud-top">
                <div class="level-box">
                    <div class="level-badge">LV.<span id="levelDisp">1</span></div>
                    <div class="kill-count">‚ò†Ô∏è <span id="killDisp">0</span></div>
                </div>
                <div class="timer" id="timeDisp">00:00</div>
            </div>
            <div id="joystick-zone"><div id="stick"></div></div>
        </div>

        <div id="levelUpScreen">
            <h1 style="color:#FFD700; text-shadow:0 0 20px #FFD700;">LEVEL UP!</h1>
            <div id="skillOptions" style="width:100%; display:flex; flex-direction:column; align-items:center;"></div>
        </div>

        <div id="gameOverScreen">
            <h1 style="color:#ff4757; font-size:3rem; margin:0;">YOU DIED</h1>
            <p style="color:white; font-size:1.2rem;">Í∏∞Î°ù: <span id="finalTime">00:00</span></p>
            <button class="btn btn-revive" onclick="revive()">üì∫ Í¥ëÍ≥†Î≥¥Í≥† Î∂ÄÌôú</button>
            <button class="btn" onclick="location.reload()" style="background:#fff;">Îã§Ïãú ÌïòÍ∏∞</button>
            <a href="../../index.html" style="color:#aaa; margin-top:20px; display:block; text-decoration:none;">ÌôàÏúºÎ°ú</a>
        </div>

        <div class="ad-banner-area" id="ad-game-bottom"></div>
    </div>

    <audio id="bgm" src="../../audio/magic-survivor/bgm_battle.mp3" loop></audio>
    <audio id="sfx-hit" src="../../audio/magic-survivor/sfx_hit.mp3"></audio>
    <audio id="sfx-levelup" src="../../audio/magic-survivor/sfx_levelup.mp3"></audio>
    <audio id="sfx-magic" src="../../audio/magic-survivor/sfx_magic.mp3"></audio>

    <script src="../../js/ads.js"></script>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let W, H;
        function resize() {
            const dpr = window.devicePixelRatio || 1;
            W = window.innerWidth; H = window.innerHeight;
            canvas.width = W * dpr; canvas.height = H * dpr;
            canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
            ctx.scale(dpr, dpr); ctx.imageSmoothingEnabled = true;
        }
        window.addEventListener('resize', resize);
        resize();

        const images = {};
        const assetNames = ['player', 'bg_tile', 'enemy_1', 'enemy_2', 'enemy_boss', 'gem', 'icon_fireball', 'icon_lightning', 'icon_shield', 'icon_heal'];
        assetNames.forEach(name => {
            images[name] = new Image();
            images[name].src = `../../images/magic-survivor/${name}.png`;
        });

        let gameState = 'playing';
        let frames = 0, score = 0, timeSeconds = 0, level = 1, xp = 0, xpNext = 100;

        // [ÏàòÏ†ï] ÌîåÎ†àÏù¥Ïñ¥ Í∏∞Î≥∏ ÌÅ¨Í∏∞ ÌôïÎåÄ (80 -> 100)
        const player = { x: W/2, y: H/2, speed: 4, hp: 100, maxHp: 100, size: 100, dir: 1 };
        
        let enemies = [], gems = [], projectiles = [], floats = [], particles = [];

        const SKILLS = {
            fireball: { name: "ÌôîÏóºÍµ¨", desc: "Ï†ÅÏùÑ Ï∂îÏ†ÅÌïòÎäî Î∂àÎç©Ïù¥", level: 1, dmg: 30, cd: 50, timer: 0, color: '#ff6b6b', icon: 'icon_fireball' },
            lightning: { name: "Î≤ºÎùΩ", desc: "Î¨¥ÏûëÏúÑ Ï†Å ÌÉÄÍ≤©", level: 0, dmg: 80, cd: 100, timer: 0, color: '#feca57', icon: 'icon_lightning' },
            shield: { name: "ÌöåÏ†Ñ ÏπºÎÇ†", desc: "Ï£ºÎ≥ÄÏùÑ Î≥¥Ìò∏", level: 0, dmg: 15, count: 0, color: '#48dbfb', icon: 'icon_shield' },
            heal: { name: "Ïû¨ÏÉù", desc: "Ï≤¥Î†• ÌöåÎ≥µ", level: 0, amount: 10, cd: 300, timer: 0, color: '#1dd1a1', icon: 'icon_heal' }
        };

        const keys = {};
        const joy = { active: false, dx: 0, dy: 0, ox: 0, oy: 0 };

        function loop() {
            if (gameState === 'playing') {
                try { update(); draw(); frames++; } 
                catch (e) { console.error(e); }
            }
            requestAnimationFrame(loop);
        }

        function update() {
            let mx = 0, my = 0;
            if (keys['ArrowUp'] || keys['w']) my = -1;
            if (keys['ArrowDown'] || keys['s']) my = 1;
            if (keys['ArrowLeft'] || keys['a']) mx = -1;
            if (keys['ArrowRight'] || keys['d']) mx = 1;
            if (joy.active) { mx = joy.dx; my = joy.dy; }

            if (mx !== 0 || my !== 0) {
                const len = Math.sqrt(mx*mx + my*my);
                mx /= len; my /= len;
                player.x += mx * player.speed;
                player.y += my * player.speed;
                if(mx !== 0) player.dir = mx > 0 ? 1 : -1;
            }
            
            const limit = 2000;
            player.x = Math.max(-limit, Math.min(limit, player.x));
            player.y = Math.max(-limit, Math.min(limit, player.y));

            updateSkills();

            if (frames % 60 === 0) {
                timeSeconds++;
                document.getElementById('timeDisp').innerText = formatTime(timeSeconds);
            }
            if (frames % Math.max(20, 60 - Math.floor(timeSeconds/5)) === 0) spawnEnemy();

            enemies.forEach((e, i) => {
                const angle = Math.atan2(player.y - e.y, player.x - e.x);
                e.x += Math.cos(angle) * e.speed;
                e.y += Math.sin(angle) * e.speed;
                
                // Ï∂©Îèå Î≤îÏúÑ Ï°∞Ï†ï (Ï°∞Í∏à Îçî Í¥ÄÎåÄÌïòÍ≤å)
                const dist = Math.hypot(player.x - e.x, player.y - e.y);
                if (dist < player.size*0.3 + e.size*0.3) {
                    player.hp -= 0.2;
                    if (player.hp <= 0) gameOver();
                }
            });

            projectiles.forEach(p => {
                p.x += Math.cos(p.angle) * p.speed;
                p.y += Math.sin(p.angle) * p.speed;
                p.life--;
                enemies.forEach((e, ei) => {
                    if (p.life <= 0) return;
                    if (Math.hypot(p.x - e.x, p.y - e.y) < p.size + e.size*0.4) {
                        hitEnemy(e, ei, p.damage);
                        p.life = 0;
                        createParticles(e.x, e.y, p.color);
                    }
                });
            });
            projectiles = projectiles.filter(p => p.life > 0);

            gems.forEach((g, i) => {
                const dist = Math.hypot(player.x - g.x, player.y - g.y);
                if (dist < 200) { g.x += (player.x - g.x)*0.1; g.y += (player.y - g.y)*0.1; }
                if (dist < 50) { getGem(g.xp); gems.splice(i, 1); }
            });

            floats = floats.filter(t => t.life-- > 0);
            particles = particles.filter(p => p.life-- > 0);
        }

        function draw() {
            const cx = player.x - W/2;
            const cy = player.y - H/2;

            // [ÏàòÏ†ï] Î∞∞Í≤Ω ÌÉÄÏùº Ïä§ÏºÄÏùº Ï∂ïÏÜå (2 -> 1.2)
            if (images.bg_tile.complete) {
                const ptrn = ctx.createPattern(images.bg_tile, 'repeat');
                ctx.fillStyle = ptrn;
                ctx.save();
                ctx.scale(1.2, 1.2); // ÌÉÄÏùº ÌÅ¨Í∏∞ Ï§ÑÏûÑ
                ctx.translate(-cx/1.2, -cy/1.2);
                ctx.fillRect(cx/1.2, cy/1.2, W/1.2, H/1.2);
                ctx.restore();
            } else {
                ctx.fillStyle = '#2c3e50'; ctx.fillRect(0, 0, W, H);
            }

            ctx.save();
            ctx.translate(-cx, -cy);

            gems.forEach(g => {
                if(images.gem.complete) ctx.drawImage(images.gem, g.x-15, g.y-15, 30, 30);
                else { ctx.fillStyle='#00ff9d'; ctx.beginPath(); ctx.arc(g.x, g.y, 8, 0, Math.PI*2); ctx.fill(); }
            });

            // Ï†Å Í∑∏Î¶¨Í∏∞ (ÎπÑÏú® Ï°∞Ï†ï)
            enemies.forEach(e => {
                ctx.save(); ctx.translate(e.x, e.y);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath(); ctx.ellipse(0, e.size/2-5, e.size*0.4, e.size*0.2, 0, 0, Math.PI*2); ctx.fill();
                
                if (e.x < player.x) ctx.scale(-1, 1);
                let img = images['enemy_' + e.type] || images.enemy_1;
                if(img.complete) {
                    // [ÌïµÏã¨] Ï†ïÏÇ¨Í∞ÅÌòïÏù¥ ÏïÑÎãå ÏßÅÏÇ¨Í∞ÅÌòï ÎπÑÏú®Î°ú Í∑∏Î¶º (Ìè≠ÏùÑ ÎÜíÏù¥Ïùò 80%Î°ú)
                    const width = e.size * 0.8;
                    ctx.drawImage(img, -width/2, -e.size/2, width, e.size);
                }
                else { ctx.fillStyle='red'; ctx.fillRect(-e.size/2, -e.size/2, e.size, e.size); }
                ctx.restore();
            });

            // ÌîåÎ†àÏù¥Ïñ¥ Í∑∏Î¶¨Í∏∞ (ÎπÑÏú® Ï°∞Ï†ï & ÌÅ¨Í∏∞ ÌôïÎåÄ)
            ctx.save(); ctx.translate(player.x, player.y);
            // Í∑∏Î¶ºÏûê
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(0, player.size/2-5, player.size*0.4, player.size*0.2, 0, 0, Math.PI*2); ctx.fill();

            if (player.dir < 0) ctx.scale(-1, 1);
            if (images.player.complete) {
                // [ÌïµÏã¨] ÌîåÎ†àÏù¥Ïñ¥ÎèÑ Ìè≠ÏùÑ ÎÜíÏù¥Ïùò 80%Î°ú ÏÑ§Ï†ïÌïòÏó¨ ÎÇ†Ïî¨ÌïòÍ≤å ÎßåÎì¶
                const width = player.size * 0.8;
                ctx.drawImage(images.player, -width/2, -player.size/2, width, player.size);
            }
            else { ctx.fillStyle='white'; ctx.fillRect(-20, -20, 40, 40); }
            
            // Ï≤¥Î†•Î∞î
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(-40, -player.size/2 - 20, 80, 10);
            ctx.fillStyle = '#00ff9d'; ctx.fillRect(-40, -player.size/2 - 20, 80 * (player.hp/player.maxHp), 10);
            ctx.restore();

            projectiles.forEach(p => {
                ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
            });
            particles.forEach(p => {
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life/20;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1;
            });
            floats.forEach(t => {
                ctx.fillStyle = t.color || 'white'; 
                ctx.font = 'bold 24px Arial';
                ctx.shadowColor="black"; ctx.shadowBlur=3;
                ctx.fillText(t.text, t.x, t.y - (30-t.life));
                ctx.shadowBlur=0;
            });
            
            if(SKILLS.shield.level > 0) drawShield();
            ctx.restore();
        }

        function updateSkills() {
            if (SKILLS.fireball.level > 0) {
                SKILLS.fireball.timer++;
                if (SKILLS.fireball.timer >= Math.max(10, 60 - SKILLS.fireball.level*2)) {
                    SKILLS.fireball.timer = 0;
                    const t = getNearest();
                    if(t) { shoot(player.x, player.y, t, SKILLS.fireball.dmg, SKILLS.fireball.color, 10); playSound('magic'); }
                }
            }
            if (SKILLS.lightning.level > 0) {
                SKILLS.lightning.timer++;
                if (SKILLS.lightning.timer >= 120) {
                    SKILLS.lightning.timer = 0;
                    const t = getRandomEnemy();
                    if(t) { hitEnemy(t, enemies.indexOf(t), SKILLS.lightning.dmg); createParticles(t.x, t.y, SKILLS.lightning.color, 15); createFloatText("‚ö°", t.x, t.y-40, 'yellow'); }
                }
            }
            if (SKILLS.heal.level > 0) {
                SKILLS.heal.timer++;
                if (SKILLS.heal.timer >= 300) {
                    SKILLS.heal.timer = 0;
                    player.hp = Math.min(player.maxHp, player.hp + SKILLS.heal.amount);
                    createFloatText("HEAL", player.x, player.y - 60, '#00ff9d');
                }
            }
            if (SKILLS.shield.level > 0) {
                const cnt = SKILLS.shield.level;
                const t = Date.now() / 500;
                for(let i=0; i<cnt; i++) {
                    const a = t + (Math.PI*2 * i / cnt);
                    const sx = player.x + Math.cos(a)*120; // Î≤îÏúÑ ÌôïÎåÄ
                    const sy = player.y + Math.sin(a)*120;
                    enemies.forEach((e, ei) => {
                        if(Math.hypot(sx-e.x, sy-e.y) < 50) hitEnemy(e, ei, SKILLS.shield.dmg);
                    });
                }
            }
        }
        
        function drawShield() {
            const cnt = SKILLS.shield.level;
            const t = Date.now() / 500;
            for(let i=0; i<cnt; i++) {
                const a = t + (Math.PI*2 * i / cnt);
                const sx = player.x + Math.cos(a)*120;
                const sy = player.y + Math.sin(a)*120;
                if(images.icon_shield.complete) ctx.drawImage(images.icon_shield, sx-25, sy-25, 50, 50);
                else { ctx.fillStyle='cyan'; ctx.beginPath(); ctx.arc(sx, sy, 20, 0, Math.PI*2); ctx.fill(); }
            }
        }
        function shoot(x, y, t, dmg, col, spd) {
            const a = Math.atan2(t.y - y, t.x - x);
            projectiles.push({ x, y, angle: a, speed: spd, damage: dmg, color: col, size: 10, life: 60 });
        }
        function hitEnemy(e, idx, dmg) {
            e.hp -= dmg;
            createFloatText(dmg, e.x, e.y, 'white');
            if (e.hp <= 0) {
                gems.push({ x: e.x, y: e.y, xp: e.type * 10 });
                score++;
                document.getElementById('killDisp').innerText = score;
                enemies.splice(idx, 1);
                playSound('hit');
            }
        }
        function spawnEnemy() {
            const a = Math.random() * Math.PI * 2;
            const d = Math.max(W, H) / 2 + 150;
            const x = player.x + Math.cos(a) * d;
            const y = player.y + Math.sin(a) * d;
            // [ÏàòÏ†ï] Ï†Å ÌÅ¨Í∏∞ÎèÑ Ï†ÑÏ≤¥Ï†ÅÏúºÎ°ú ÌôïÎåÄ
            let type=1, size=80, hp=20+timeSeconds, spd=1.5;
            if(timeSeconds > 60 && Math.random()<0.3) { type=2; hp*=2; size=110; spd=1.2; }
            if(timeSeconds > 120 && Math.random()<0.05) { type='boss'; hp*=10; size=200; spd=0.8; }
            enemies.push({ x, y, hp, maxHp:hp, type, speed:spd, size });
        }
        function getGem(amount) {
            xp += amount;
            if (xp >= xpNext) { xp = 0; xpNext = Math.floor(xpNext * 1.2); levelUp(); }
            document.getElementById('xpBar').style.width = (xp/xpNext*100) + "%";
        }
        function levelUp() {
            gameState = 'paused'; level++;
            document.getElementById('levelDisp').innerText = level;
            playSound('levelup');
            const list = document.getElementById('skillOptions'); list.innerHTML = "";
            const keys = Object.keys(SKILLS).sort(()=>0.5-Math.random()).slice(0,3);
            keys.forEach(k => {
                const s = SKILLS[k];
                const div = document.createElement('div');
                div.className = 'skill-card';
                div.innerHTML = `<img src="../../images/magic-survivor/${s.icon}.png" class="skill-icon"><div class="skill-info"><h3>${s.name} <small>Lv.${s.level}</small></h3><p>${s.desc}</p></div>`;
                div.onclick = () => { s.level++; document.getElementById('levelUpScreen').style.display='none'; gameState='playing'; };
                list.appendChild(div);
            });
            document.getElementById('levelUpScreen').style.display = 'flex';
        }
        function gameOver() {
            gameState = 'gameover';
            document.getElementById('bgm').pause();
            document.getElementById('finalTime').innerText = formatTime(timeSeconds);
            document.getElementById('gameOverScreen').style.display = 'flex';
        }
        function revive() {
            if(window.showRewardAd) {
                window.showRewardAd(() => {
                    player.hp = player.maxHp; enemies = []; gameState = 'playing';
                    document.getElementById('gameOverScreen').style.display = 'none';
                    document.getElementById('bgm').play();
                });
            } else alert("Í¥ëÍ≥† Î°úÎî© Ï§ë...");
        }
        
        function createFloatText(txt, x, y, color) { floats.push({ text: txt, x, y, life: 40, color: color }); }
        function createParticles(x, y, color, count=5) { for(let i=0; i<count; i++) particles.push({ x, y, color, size: Math.random()*5+3, life: 25 }); }
        function getNearest() { let t=null, min=Infinity; enemies.forEach(e=>{ const d=Math.hypot(e.x-player.x, e.y-player.y); if(d<min){min=d; t=e;} }); return t; }
        function getRandomEnemy() { return enemies[Math.floor(Math.random()*enemies.length)]; }
        function formatTime(s) { return `${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`; }
        function playSound(id) { try{const s=document.getElementById('sfx-'+id); if(s){s.currentTime=0;s.play().catch(()=>{});}}catch(e){} }

        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);
        const jz = document.getElementById('joystick-zone'), stick = document.getElementById('stick');
        jz.addEventListener('touchstart', e => { joy.active = true; joy.ox = e.touches[0].clientX; joy.oy = e.touches[0].clientY; });
        jz.addEventListener('touchmove', e => { if(!joy.active) return; const dx = e.touches[0].clientX - joy.ox; const dy = e.touches[0].clientY - joy.oy; const dist = Math.min(60, Math.sqrt(dx*dx+dy*dy)); const a = Math.atan2(dy, dx); stick.style.transform = `translate(calc(-50% + ${Math.cos(a)*dist}px), calc(-50% + ${Math.sin(a)*dist}px))`; joy.dx = Math.cos(a); joy.dy = Math.sin(a); });
        jz.addEventListener('touchend', () => { joy.active = false; joy.dx=0; joy.dy=0; stick.style.transform = `translate(-50%, -50%)`; });
        window.addEventListener('click', ()=>{ const bgm=document.getElementById('bgm'); if(bgm.paused) { bgm.volume=0.3; bgm.play().catch(()=>{}); } }, {once:true});

        loop();
    </script>
</body>
</html>