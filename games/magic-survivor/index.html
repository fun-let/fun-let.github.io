<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë§¤ì§ ì„œë°”ì´ë²„ V2</title>
    <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Noto+Sans+KR:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Noto Sans KR', sans-serif; touch-action: none; user-select: none; }
        
        #gameLayer { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
        canvas { display: block; }

        /* UI ë ˆì´ì–´ */
        .ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* ìƒë‹¨ ì •ë³´ì°½ */
        .hud-top { display: flex; justify-content: space-between; padding: 15px; pointer-events: none; z-index: 20; position: relative; }
        .xp-bar-container { 
            position: absolute; top: 0; left: 0; width: 100%; height: 10px; background: #333; z-index: 10; 
        }
        .xp-bar { width: 0%; height: 100%; background: #00ff9d; transition: width 0.2s; box-shadow: 0 0 10px #00ff9d; }
        
        .level-box { text-align: left; }
        .level-badge { background: rgba(0,0,0,0.7); color: white; padding: 5px 15px; border-radius: 20px; font-weight: bold; border: 2px solid #00ff9d; display: inline-block; margin-bottom: 5px; }
        
        .timer { font-family: 'Black Han Sans'; font-size: 2rem; color: white; text-shadow: 3px 3px 0 #000; position: absolute; left: 50%; transform: translateX(-50%); top: 20px; }
        .kill-count { color: #ff4757; font-weight: bold; text-shadow: 1px 1px 0 #000; font-size: 1.2rem; }

        /* ë ˆë²¨ì—… ì„ íƒì°½ */
        #levelUpScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100; display: none;
            flex-direction: column; align-items: center; justify-content: center; pointer-events: auto;
        }
        .skill-card {
            background: #222; border: 2px solid #444; border-radius: 15px;
            padding: 15px; margin: 10px; width: 85%; max-width: 400px;
            display: flex; align-items: center; gap: 15px; cursor: pointer; transition: 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .skill-card:hover { background: #333; border-color: #00ff9d; transform: scale(1.05); }
        .skill-icon { width: 60px; height: 60px; background: #000; border-radius: 10px; object-fit: cover; border: 1px solid #555; }
        .skill-info h3 { margin: 0; color: #00ff9d; font-size: 1.2rem; }
        .skill-info p { margin: 5px 0 0; color: #ccc; font-size: 0.9rem; }

        /* ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹± */
        #joystick-zone {
            position: absolute; bottom: 150px; left: 50%; transform: translateX(-50%);
            width: 120px; height: 120px; z-index: 50; pointer-events: auto;
            border: 2px solid rgba(255,255,255,0.2); border-radius: 50%;
            display: none; /* ëª¨ë°”ì¼ì—ì„œë§Œ ì¼œì§ */
        }
        #stick {
            width: 50px; height: 50px; background: rgba(0,255,157,0.5); border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0,255,157,0.5);
        }

        /* ê²Œì„ ì˜¤ë²„ */
        #gameOverScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.9); z-index: 200; display: none;
            flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; text-align: center;
        }
        .btn {
            background: #00ff9d; color: black; border: none; padding: 15px 40px;
            font-size: 1.2rem; border-radius: 50px; font-family: 'Black Han Sans';
            margin-top: 15px; cursor: pointer; box-shadow: 0 5px 0 #00b870;
        }
        .btn-revive { background: #FFD700; box-shadow: 0 5px 0 #c5a600; animation: pulse 1s infinite; }
        @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.05);} 100% {transform: scale(1);} }

        /* í•˜ë‹¨ ë°°ë„ˆ ì˜ì—­ */
        .ad-banner-area { 
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100px; 
            background: rgba(0,0,0,0.8); z-index: 90; pointer-events: auto;
            display: flex; justify-content: center; align-items: center;
        }

        @media (max-width: 768px) {
            #joystick-zone { display: block; } /* ëª¨ë°”ì¼ì—ì„œ ì¡°ì´ìŠ¤í‹± ë³´ì„ */
        }
    </style>
</head>
<body>

    <div id="gameLayer">
        <canvas id="gameCanvas"></canvas>

        <div class="ui-overlay">
            <div class="xp-bar-container"><div class="xp-bar" id="xpBar"></div></div>
            
            <div class="hud-top">
                <div class="level-box">
                    <div class="level-badge">LV.<span id="levelDisp">1</span></div>
                    <div class="kill-count">â˜ ï¸ <span id="killDisp">0</span></div>
                </div>
                <div class="timer" id="timeDisp">00:00</div>
            </div>

            <div id="joystick-zone">
                <div id="stick"></div>
            </div>
        </div>

        <div id="levelUpScreen">
            <h1 style="color:#FFD700; text-shadow:0 0 20px #FFD700;">LEVEL UP!</h1>
            <div id="skillOptions" style="width:100%; display:flex; flex-direction:column; align-items:center;"></div>
        </div>

        <div id="gameOverScreen">
            <h1 style="color:#ff4757; font-size:3rem; margin:0;">YOU DIED</h1>
            <p style="color:white; font-size:1.2rem;">ë²„í‹´ ì‹œê°„: <span id="finalTime">00:00</span></p>
            <button class="btn btn-revive" onclick="revive()">ğŸ“º ê´‘ê³ ë³´ê³  ë¶€í™œ (HP 100%)</button>
            <button class="btn" onclick="location.reload()" style="background:#fff;">ë‹¤ì‹œ í•˜ê¸°</button>
            <a href="../../index.html" style="color:#aaa; margin-top:20px; display:block; text-decoration:none;">í™ˆìœ¼ë¡œ</a>
        </div>

        <div class="ad-banner-area" id="ad-game-bottom"></div>
    </div>

    <audio id="bgm" src="../../audio/magic-survivor/bgm_battle.mp3" loop></audio>
    <audio id="sfx-hit" src="../../audio/magic-survivor/sfx_hit.mp3"></audio>
    <audio id="sfx-levelup" src="../../audio/magic-survivor/sfx_levelup.mp3"></audio>
    <audio id="sfx-magic" src="../../audio/magic-survivor/sfx_magic.mp3"></audio>

    <script src="../../js/ads.js"></script>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // í™”ë©´ í¬ê¸° ì„¤ì •
        let W, H;
        function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize);
        resize();

        // ì´ë¯¸ì§€ ë¡œë“œ (ì—†ìœ¼ë©´ ì‚¬ê°í˜•ìœ¼ë¡œ ëŒ€ì²´ë˜ë‹ˆ ì•ˆì‹¬í•˜ì„¸ìš”)
        const images = {};
        const assetNames = ['player', 'bg_tile', 'enemy_1', 'enemy_2', 'enemy_boss', 'gem', 'icon_fireball', 'icon_lightning', 'icon_shield', 'icon_heal'];
        assetNames.forEach(name => {
            images[name] = new Image();
            images[name].src = `../../images/magic-survivor/${name}.png`;
        });

        // ê²Œì„ ë³€ìˆ˜
        let gameState = 'playing';
        let frames = 0;
        let score = 0;
        let timeSeconds = 0;
        let level = 1;
        let xp = 0;
        let xpNext = 100;

        // ì—”í‹°í‹°
        const player = { x: W/2, y: H/2, speed: 4, hp: 100, maxHp: 100, size: 40, dir: 1 };
        let enemies = [];
        let gems = [];
        let projectiles = [];
        let floats = []; // ë°ë¯¸ì§€ í…ìŠ¤íŠ¸
        let particles = []; // íŒŒí‹°í´

        // ìŠ¤í‚¬ ëª©ë¡
        const SKILLS = {
            fireball: { name: "í™”ì—¼êµ¬", desc: "ê°€ì¥ ê°€ê¹Œìš´ ì ì—ê²Œ ë¶ˆë©ì´ ë°œì‚¬", level: 1, dmg: 30, cd: 50, timer: 0, color: '#ff6b6b', icon: 'icon_fireball' },
            lightning: { name: "ë²¼ë½", desc: "ë¬´ì‘ìœ„ ì ì—ê²Œ ë²¼ë½ì„ ê½‚ìŒ", level: 0, dmg: 80, cd: 100, timer: 0, color: '#feca57', icon: 'icon_lightning' },
            shield: { name: "íšŒì „ ì¹¼ë‚ ", desc: "ì£¼ë³€ì„ ë„ëŠ” ì¹¼ë‚  ìƒì„±", level: 0, dmg: 15, count: 0, color: '#48dbfb', icon: 'icon_shield' },
            heal: { name: "ì¬ìƒë ¥", desc: "5ì´ˆë§ˆë‹¤ ì²´ë ¥ íšŒë³µ", level: 0, amount: 10, cd: 300, timer: 0, color: '#1dd1a1', icon: 'icon_heal' }
        };

        // ì…ë ¥
        const keys = {};
        const joy = { active: false, dx: 0, dy: 0, ox: 0, oy: 0 };

        // --- ê²Œì„ ë£¨í”„ ---
        function loop() {
            if (gameState === 'playing') {
                try {
                    update();
                    draw();
                    frames++;
                } catch (e) {
                    console.error("ê²Œì„ ë£¨í”„ ì—ëŸ¬:", e);
                }
            }
            requestAnimationFrame(loop);
        }

        function update() {
            // 1. í”Œë ˆì´ì–´ ì´ë™
            let mx = 0, my = 0;
            if (keys['ArrowUp'] || keys['w']) my = -1;
            if (keys['ArrowDown'] || keys['s']) my = 1;
            if (keys['ArrowLeft'] || keys['a']) mx = -1;
            if (keys['ArrowRight'] || keys['d']) mx = 1;

            if (joy.active) { mx = joy.dx; my = joy.dy; }

            if (mx !== 0 || my !== 0) {
                const len = Math.sqrt(mx*mx + my*my);
                mx /= len; my /= len;
                player.x += mx * player.speed;
                player.y += my * player.speed;
                if(mx !== 0) player.dir = mx > 0 ? 1 : -1;
            }

            // ë§µ ì œí•œ
            const limit = 2000;
            player.x = Math.max(-limit, Math.min(limit, player.x));
            player.y = Math.max(-limit, Math.min(limit, player.y));

            // 2. ìŠ¤í‚¬ ì—…ë°ì´íŠ¸
            updateSkills();

            // 3. ì  ìƒì„± ë° ì´ë™
            if (frames % 60 === 0) {
                timeSeconds++;
                document.getElementById('timeDisp').innerText = formatTime(timeSeconds);
            }
            // ì  ìŠ¤í° ì†ë„ ì¡°ì ˆ
            if (frames % Math.max(20, 60 - Math.floor(timeSeconds/5)) === 0) spawnEnemy();

            enemies.forEach((e, i) => {
                const angle = Math.atan2(player.y - e.y, player.x - e.x);
                e.x += Math.cos(angle) * e.speed;
                e.y += Math.sin(angle) * e.speed;

                // í”Œë ˆì´ì–´ ì¶©ëŒ (í”¼ê²©)
                const dist = Math.hypot(player.x - e.x, player.y - e.y);
                if (dist < player.size/2 + e.size/2) {
                    player.hp -= 0.2; // ì§€ì† ë°ë¯¸ì§€
                    if (player.hp <= 0) gameOver();
                }
            });

            // 4. íˆ¬ì‚¬ì²´ ì´ë™
            projectiles.forEach(p => {
                p.x += Math.cos(p.angle) * p.speed;
                p.y += Math.sin(p.angle) * p.speed;
                p.life--;
                
                // ì  ì¶©ëŒ
                enemies.forEach((e, ei) => {
                    if (p.life <= 0) return;
                    if (Math.hypot(p.x - e.x, p.y - e.y) < p.size + e.size/2) {
                        hitEnemy(e, ei, p.damage);
                        p.life = 0;
                        createParticles(e.x, e.y, p.color);
                    }
                });
            });
            projectiles = projectiles.filter(p => p.life > 0);

            // 5. ì•„ì´í…œ íšë“ (ìì„)
            gems.forEach((g, i) => {
                const dist = Math.hypot(player.x - g.x, player.y - g.y);
                if (dist < 150) {
                    g.x += (player.x - g.x) * 0.1;
                    g.y += (player.y - g.y) * 0.1;
                }
                if (dist < 30) {
                    getGem(g.xp);
                    gems.splice(i, 1);
                }
            });

            // íš¨ê³¼ ì—…ë°ì´íŠ¸
            floats = floats.filter(t => t.life-- > 0);
            particles = particles.filter(p => p.life-- > 0);
        }

        function draw() {
            // ì¹´ë©”ë¼
            const cx = player.x - W/2;
            const cy = player.y - H/2;

            // ë°°ê²½
            if (images.bg_tile.complete) {
                const ptrn = ctx.createPattern(images.bg_tile, 'repeat');
                ctx.fillStyle = ptrn;
                ctx.save(); ctx.translate(-cx, -cy); ctx.fillRect(cx, cy, W, H); ctx.restore();
            } else {
                ctx.fillStyle = '#222'; ctx.fillRect(0, 0, W, H);
            }

            ctx.save();
            ctx.translate(-cx, -cy);

            // ì•„ì´í…œ
            gems.forEach(g => {
                if(images.gem.complete) ctx.drawImage(images.gem, g.x-10, g.y-10, 20, 20);
                else { ctx.fillStyle='#00ff9d'; ctx.beginPath(); ctx.arc(g.x, g.y, 5, 0, Math.PI*2); ctx.fill(); }
            });

            // ì 
            enemies.forEach(e => {
                ctx.save(); ctx.translate(e.x, e.y);
                if (e.x < player.x) ctx.scale(-1, 1);
                let img = images['enemy_' + e.type] || images.enemy_1;
                if(img.complete) ctx.drawImage(img, -e.size/2, -e.size/2, e.size, e.size);
                else { ctx.fillStyle='red'; ctx.fillRect(-e.size/2, -e.size/2, e.size, e.size); }
                ctx.restore();
            });

            // í”Œë ˆì´ì–´
            ctx.save(); ctx.translate(player.x, player.y);
            if (player.dir < 0) ctx.scale(-1, 1);
            if (images.player.complete) ctx.drawImage(images.player, -25, -25, 50, 50);
            else { ctx.fillStyle='white'; ctx.fillRect(-20, -20, 40, 40); }
            // ì²´ë ¥ë°”
            ctx.fillStyle = 'red'; ctx.fillRect(-20, -35, 40, 5);
            ctx.fillStyle = '#00ff9d'; ctx.fillRect(-20, -35, 40 * (player.hp/player.maxHp), 5);
            ctx.restore();

            // ì´í™íŠ¸
            projectiles.forEach(p => {
                ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
            });
            particles.forEach(p => {
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life/20;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1;
            });
            floats.forEach(t => {
                ctx.fillStyle = t.color || 'white'; ctx.font = 'bold 20px Arial';
                ctx.fillText(t.text, t.x, t.y - (30-t.life));
            });
            
            // ì‰´ë“œ ê·¸ë¦¬ê¸°
            if(SKILLS.shield.level > 0) drawShield();

            ctx.restore();
        }

        function updateSkills() {
            // 1. í™”ì—¼êµ¬
            if (SKILLS.fireball.level > 0) {
                SKILLS.fireball.timer++;
                if (SKILLS.fireball.timer >= Math.max(10, 60 - SKILLS.fireball.level*2)) {
                    SKILLS.fireball.timer = 0;
                    const t = getNearest();
                    if(t) {
                        shoot(player.x, player.y, t, SKILLS.fireball.dmg, SKILLS.fireball.color, 8);
                        playSound('magic');
                    }
                }
            }
            // 2. ë²¼ë½
            if (SKILLS.lightning.level > 0) {
                SKILLS.lightning.timer++;
                if (SKILLS.lightning.timer >= 120) {
                    SKILLS.lightning.timer = 0;
                    const t = getRandomEnemy();
                    if(t) {
                        hitEnemy(t, enemies.indexOf(t), SKILLS.lightning.dmg);
                        createParticles(t.x, t.y, SKILLS.lightning.color, 10);
                        createFloatText("âš¡", t.x, t.y-20, 'yellow');
                    }
                }
            }
            // 3. íšŒë³µ
            if (SKILLS.heal.level > 0) {
                SKILLS.heal.timer++;
                if (SKILLS.heal.timer >= 300) {
                    SKILLS.heal.timer = 0;
                    player.hp = Math.min(player.maxHp, player.hp + SKILLS.heal.amount);
                    createFloatText("â™¥", player.x, player.y - 30, '#00ff9d');
                }
            }
            // 4. ì‰´ë“œ ì¶©ëŒ
            if (SKILLS.shield.level > 0) {
                const cnt = SKILLS.shield.level;
                const t = Date.now() / 500;
                for(let i=0; i<cnt; i++) {
                    const a = t + (Math.PI*2 * i / cnt);
                    const sx = player.x + Math.cos(a)*70;
                    const sy = player.y + Math.sin(a)*70;
                    enemies.forEach((e, ei) => {
                        if(Math.hypot(sx-e.x, sy-e.y) < 30) hitEnemy(e, ei, SKILLS.shield.dmg);
                    });
                }
            }
        }

        function drawShield() {
            const cnt = SKILLS.shield.level;
            const t = Date.now() / 500;
            for(let i=0; i<cnt; i++) {
                const a = t + (Math.PI*2 * i / cnt);
                const sx = player.x + Math.cos(a)*70;
                const sy = player.y + Math.sin(a)*70;
                if(images.icon_shield.complete) ctx.drawImage(images.icon_shield, sx-15, sy-15, 30, 30);
                else { ctx.fillStyle='cyan'; ctx.beginPath(); ctx.arc(sx, sy, 10, 0, Math.PI*2); ctx.fill(); }
            }
        }

        function shoot(x, y, t, dmg, col, spd) {
            const a = Math.atan2(t.y - y, t.x - x);
            projectiles.push({ x, y, angle: a, speed: spd, damage: dmg, color: col, size: 5, life: 60 });
        }

        function hitEnemy(e, idx, dmg) {
            e.hp -= dmg;
            createFloatText(dmg, e.x, e.y, 'white');
            if (e.hp <= 0) {
                gems.push({ x: e.x, y: e.y, xp: e.type * 10 });
                score++;
                document.getElementById('killDisp').innerText = score;
                enemies.splice(idx, 1);
                playSound('hit');
            }
        }

        function spawnEnemy() {
            const a = Math.random() * Math.PI * 2;
            const d = Math.max(W, H) / 2 + 50;
            const x = player.x + Math.cos(a) * d;
            const y = player.y + Math.sin(a) * d;
            let type = 1; let size = 40; let hp = 20 + timeSeconds; let spd = 1.5;
            
            if(timeSeconds > 60 && Math.random()<0.3) { type=2; hp*=2; size=50; spd=1.2; }
            if(timeSeconds > 120 && Math.random()<0.05) { type='boss'; hp*=10; size=100; spd=0.8; }
            
            enemies.push({ x, y, hp, maxHp:hp, type, speed:spd, size });
        }

        function getGem(amount) {
            xp += amount;
            if (xp >= xpNext) {
                xp = 0; xpNext = Math.floor(xpNext * 1.2);
                levelUp();
            }
            document.getElementById('xpBar').style.width = (xp/xpNext*100) + "%";
        }

        function levelUp() {
            gameState = 'paused';
            level++;
            document.getElementById('levelDisp').innerText = level;
            playSound('levelup');
            
            const list = document.getElementById('skillOptions');
            list.innerHTML = "";
            // ëœë¤ 3ê°œ ìŠ¤í‚¬
            const keys = Object.keys(SKILLS).sort(()=>0.5-Math.random()).slice(0,3);
            keys.forEach(k => {
                const s = SKILLS[k];
                const div = document.createElement('div');
                div.className = 'skill-card';
                div.innerHTML = `
                    <img src="../../images/magic-survivor/${s.icon}.png" class="skill-icon" onerror="this.style.background='${s.color}'">
                    <div class="skill-info"><h3>${s.name} <small>Lv.${s.level}</small></h3><p>${s.desc}</p></div>
                `;
                div.onclick = () => { s.level++; document.getElementById('levelUpScreen').style.display='none'; gameState='playing'; };
                list.appendChild(div);
            });
            document.getElementById('levelUpScreen').style.display = 'flex';
        }

        function gameOver() {
            gameState = 'gameover';
            document.getElementById('bgm').pause();
            document.getElementById('finalTime').innerText = formatTime(timeSeconds);
            document.getElementById('gameOverScreen').style.display = 'flex';
        }
        
        function revive() {
            if(window.showRewardAd) {
                window.showRewardAd(() => {
                    player.hp = player.maxHp;
                    enemies = []; 
                    gameState = 'playing';
                    document.getElementById('gameOverScreen').style.display = 'none';
                    document.getElementById('bgm').play();
                });
            } else alert("ê´‘ê³  ë¡œë”© ì¤‘...");
        }

        // [ëˆ„ë½ë˜ì—ˆë˜ í•¨ìˆ˜ë“¤ ë³µêµ¬]
        function createFloatText(txt, x, y, color) {
            floats.push({ text: txt, x, y, life: 30, color: color });
        }
        function createParticles(x, y, color, count=5) {
            for(let i=0; i<count; i++) particles.push({ x, y, color, size: Math.random()*3+2, life: 20 });
        }
        function getNearest() {
            let t = null, min = Infinity;
            enemies.forEach(e => {
                const d = Math.hypot(e.x-player.x, e.y-player.y);
                if(d<min) { min=d; t=e; }
            });
            return t;
        }
        function getRandomEnemy() { return enemies[Math.floor(Math.random()*enemies.length)]; }
        function formatTime(s) { return `${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`; }
        function playSound(id) { try{const s=document.getElementById('sfx-'+id); if(s){s.currentTime=0;s.play().catch(()=>{});}}catch(e){} }

        // ì…ë ¥ ì²˜ë¦¬
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);
        
        // ì¡°ì´ìŠ¤í‹±
        const jz = document.getElementById('joystick-zone');
        const stick = document.getElementById('stick');
        jz.addEventListener('touchstart', e => {
            joy.active = true;
            joy.ox = e.touches[0].clientX; joy.oy = e.touches[0].clientY;
        });
        jz.addEventListener('touchmove', e => {
            if(!joy.active) return;
            const dx = e.touches[0].clientX - joy.ox;
            const dy = e.touches[0].clientY - joy.oy;
            const dist = Math.min(50, Math.sqrt(dx*dx + dy*dy));
            const angle = Math.atan2(dy, dx);
            stick.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
            joy.dx = Math.cos(angle); joy.dy = Math.sin(angle);
        });
        jz.addEventListener('touchend', () => {
            joy.active = false; joy.dx=0; joy.dy=0;
            stick.style.transform = `translate(-50%, -50%)`;
        });

        // ì‹œì‘
        window.addEventListener('click', ()=>{
            const bgm=document.getElementById('bgm');
            if(bgm.paused) { bgm.volume=0.3; bgm.play().catch(()=>{}); }
        }, {once:true});

        loop();
    </script>
</body>
</html>